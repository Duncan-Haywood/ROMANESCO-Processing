Guide_math_1.8.4

// CONSTANTE
final float PHI = (1 + sqrt(5))/2; //a number of polys use the golden ratio...
final float ROOT2 = sqrt(2); //...and the square root of two, the famous first irrationnal number by Pythagore
final float EULER = 2.718281828459045235360287471352; // Constant d'Euler








// EQUATION
///////////
decimale (float var, int n)
@ float
> choice your number of decimal after coma

roots(float valueToRoots, int n)
@ float
> return roots at "n" of a specific value












// SURFACE
//////////
perimeter_disc(int r)
@  float
> calcul the perimeter of circle

radius_from_circle_surface(int surface)
@return float
> calcul the radius of circle from the surface circle















// TRIGONOMETRY
///////////////


Direction
---------------
@ return a normal Vec2 or Vec3 direction
Vec2 target_direction(Vec2 target, Vec2 my_position)
Vec3 target_direction(Vec3 target, Vec3 my_position)


Projection
--------------
@ return Vec2 and Vec3 position
// cartesian
projection(Vec2 target)
projection(Vec2 target, float radius)
projection(Vec2 direction, Vec2 origin, float radius)
// polar
projection(float angle)
projection(float angle, float radius)

projection(Vec3 target)
projection(Vec3 target, float radius)
projection(Vec3 direction, Vec3 origin, float radius)




Angle
---------------------
angle_radians(float y, float range)
angle_degrees(float y, float range)
@ float
> return map value in scale radians or degrees

@angle_vecangle_vec(Vec2 a, Vec2 b)
@ float
> return angle from two vectors

float distance_vec(Vec2 a, Vec2 b)
@ float
> return the distance between two vectors

float deg360 (Vec2 dir)
@ return angle

float deg360 (PVector dir)
@ return angle from Vector 2D





Rotation
------------------
void rotation (float angle, float posX, float posY) ;
> make rotation

void rotation (float angle, Vec2 pos) ;
> make rotation

Vec2 rotation(Vec2 ref, Vec2 lattice, float angle)
@ Vec2
> return lattice position xy

Vec2 rotation_lattice(Vec2 ref, Vec2 lattice, float angle)
@ Vec2
> return lattice position xy






Polar
--------------
Vec3 to_polar(Vec3 cart)
@ Vec3
> return polar position from cartesian position 
componant.x = latitude
componant.y = longitude
componant.z = radius




Cartesian
--------------------------------
to_cartesian_3D(float latitude, float longitude)
@ Vec3
> return xyz position normal position

to_cartesian_3D(float latitude, float longitude, float radius)
@ Vec3 
> return xyz position radius position

to_cartesian_3D(Vec2 pos, Vec2 range, float sizeField)
@ Vec3
> don't remember what's is returned :)

to_cartesian_2D (float angle, float radius)
@ Vec2
> return xy position radius position

to_cartesian_2D (float angle)
@return Vec2
> return xy position normal position

to_cartesian_2D (float posMouse, Vec2 range, Vec2 targetRadian, float distance)
@return Vec2
> don't remember what's is returned :)

// END TRIGO
///////////////////////////












// Primitive
////////////

Triangle
////////
triangle(float a_x, float a_y, float a_z,
		float b_x, float b_y, float b_z,
		float c_x, float c_y, float c_z)
triangle(float a_x, float a_y,
		float b_x, float b_y,,
		float c_x, float c_y,)
triangle(Vec2 a, Vec2 b, Vec2 c)
triangle(Vec3 a, Vec3 b, Vec3 c)



Create a regular polygon with "n" summits
//////////////////////////////////////////
primitve(float  radius, int summits) ;
primitve(Vec2 pos, float radius, int summits) ;
primitve(Vec2 pos, float  radius, int summits, float orientation) ;

primitve(Vec3 pos, float  radius, int summits) ;
primitve(Vec3 pos, float  radius, int summits, float orientation) ;

primitve(Vec3 pos, float  radius, int summits, Vec3 rotate) ;
primitve(Vec3 pos, float  radius, int summits, float orientation, Vec3 rotate) ;


note 
> orientation is in radians.
> rotate is in radians, for X,Y and Z axis











// SPHERE
/////////


@ Vec3 [] point_coord
> return the vector list of normal points of your sphere.
Vec3 [] list_cartesian_fibonacci_sphere (int num, float step, float root) ;

@ Vec3 position
> return position of specific point of cartesian sphere
Vec3 distribution_cartesian_fibonacci_sphere(int n, int num, float step, float root)

@ Vec2 [] polar_direction
> return the vector list of polar direction, longitude and latitude
Vec2 [] list_polar_fibonacci_sphere(int num, float step)



@ Vec polar_direction
> return direction of a specific point of the polar sphere
Vec2 distribution_polar_fibonacci_sphere(int n, int num, float step)




// POLYHEDRON
polyhedron(String whichPolyhedron, String whichStyleToDraw, int size) ;
-
String which_polyhedron = 
"TETRAHEDRON", "CUBE", "OCTOHEDRON","DODECAHEDRON",
"ICOSAHEDRON","CUBOCTAHEDRON","ICOSI DODECAHEDRON",
"TRUNCATED CUBE","TRUNCATED OCTAHEDRON", "TRUNCATED DODECAHEDRON",
"TRUNCATED ICOSAHEDRON", "TRUNCATED CUBOCTAHEDRON" ;
"RHOMBIC CUBOCTAHEDRON", "RHOMBIC DODECAHEDRON","RHOMBIC TRIACONTAHEDRON", 
"RHOMBIC COSI DODECAHEDRON SMALL", "RHOMBIC COSI DODECAHEDRON GREAT"
 -
String whichStyleToDraw = "LINE", "POINT", "VERTEX"







